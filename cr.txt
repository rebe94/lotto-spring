1. Na pewno HomeController jest docelowo do wyrzucenia z projektu ;) jak widzisz nie ma dla niego nawet za bardzo miejsca odpoweidniego frontend po stronie backendu to w większych komercyjnych projektach gwóźdź do trumny jesli chodzi o utrzymanie projektu
2. Clocka z TimeConfiguration tworzyłbym jako Beana po to by móc go podmieniać w testach i w implementacji
3. Stowrzyłbym też klasę ApplicationConfig oznaczył jako @Configuration i tam tworzył te beany ogólne dla całej aplikacji jak np. Clock
4. Nie jestem przekonany co do wystawienia /configuration jako endpointu dla lotto-generatora. Jeśli projekt lotto-spring w ogóle nie korzysta z tej konfiguracji to tym bardziej wyniósłbym ją bezpośrednio do lotto-generatora. A jeśli używa, to pamiętaj, że w normalnej pracy byłby to pewnie jeden projekt, bo po co rozdzielać to na dwa osobne serwisy jak korzystają z tego samego ;) Możesz też spróbować użyć @ConfigurationProperties
5. Zdecydowanie lepszą praktyką na wstrzykiwanie konfiguracji/propertiesów zamiast @Value("${generator.service.url}") jest @ConfigurationProperties -> dlatego, że gdy propertiesów będzie więcej to łatwiej się odnaleźć w plikach i kluczach application.properties.
6. Zamiast private static final Logger LOGGER = getLogger(ResultCheckerFacade.class.getName()); warto użyć adnotacji @Sl4fj nad klasą i korzystać ze statycznego obiektu log np. log.error("Couldn't check winners scheduled for " + drawDate);
7. ustaw sobie w intellij use single class import w Editor -> Code Style -> Java -> Imports, robienie importów typu wildcard jest brzydkie :P mowa o np. import java.util.logging.* (sprawdź w pull requeście)
8. do całego GameConfigration użyłbym @ConfigurationProperties i wstrzykiwał te wartości z pliku application.properties
9. metoda getWinningNumbersRequest w interfejsie LottoNumberGenerator nie powinna nic zdradzać o tym, że idzie tam jakiś request.
Interfejs jest po to by powiedzieć jaka jest metoda, arguemnty i typ zwracany, a konkretne implementacje tego interfejsu czy to będzie zwykła kolekcja Javowowa, odczytywanie z pliku czy uderzanie klientem http do innej usługi to jest szczegół. Ten interfejs to jest taka "brama" między domeną aplikacji, a światem zewntętrznym czyli infrastrukturą.
Dlatego, też najcześciej sie robi osobny pakiet infrastructure w którym implementuje się interfejsy z domeny. Zobacz w pull requeście.
10. dodatkowo taka implementacja klienta http w infrastrukturze nie powinna odpowiadać za walidowanie numerów za pomocą import pl.lotto.lottonumbergenerator.WinningNumberValidator; dlatego, że jest to klasa z domeny i to domena powinna sama siebie walidować, a klient powinien mieć swój walidator np. czy liczba to Int a nie String, ale nie powinien sprwadzać logiki domenowej.
11. zauważyłem też, że rozmyło się tworzenie modułów w klasach np. LottoNumberGeneratorConfiguration "@Bean LottoNumberGenerator lottoNumberGenerator" nie musi być beanem, powinieneś mieć tak naprawdę fasadę jako beana a resztę tworzyć przez new w metodzie pl/lotto/lottonumbergenerator/LottoNumberGeneratorConfiguration.java:31
